#include "model.h"

//////////////////////
// Model Parameters //
//////////////////////

{% for param in model_parameters %}
float {{ param.name }}_in{% for dim in param.shape %}[{{ dim }}]{% endfor %};
{% endfor %}

{% for param in model_parameters %}
W_TYPE {{ param.name }}_fixed_in{% for dim in param.shape %}[{{ dim }}]{% endfor %};
{% endfor %}

int num_nodes_in;
int num_edges_in;

float node_feature_table_in[{{ max_nodes }}][{{ input_node_features_dim }}];
F_TYPE node_feature_table_fixed_in[{{ max_nodes }}][{{ input_node_features_dim }}];
int edge_list_in[{{ max_edges }}][2];

float model_output_kernel_float[{{ output_features_dim }}];
F_TYPE model_output_kernel_fixed[{{ output_features_dim }}];
float model_output_golden_float[{{ output_features_dim }}];

float task_golden_output[{{ output_features_dim }}];


void load_tb_parameters(){
    {% for param in model_parameters %}
    {% if param.shape_len == 1 %}
    {# load_data_1d("./tb_data/model_parameters/{{ param.name }}.bin", {{ param.name }}_in); #}
    load_data_1d<{{ param.shape[0] }}>("./tb_data/model_parameters/{{ param.name }}.bin", {{ param.name }}_in);
    {% elif param.shape_len == 2 %}
    load_data_2d<{{ param.shape[0] }}, {{ param.shape[1] }}>("./tb_data/model_parameters/{{ param.name }}.bin", {{ param.name }}_in);
    {% elif param.shape_len == 3 %}
    load_data_3d<{{ param.shape[0] }}, {{ param.shape[1] }}, {{ param.shape[2] }}>("./tb_data/model_parameters/{{ param.name }}.bin", {{ param.name }}_in);
    {% endif %}
    {% endfor %}

    // cast the data to fixed point
    {% for param in model_parameters %}
    {% if param.shape_len == 1 %}
    cast_1d<{{ param.shape[0] }}, float, W_TYPE>({{ param.name }}_in, {{ param.name }}_fixed_in);
    {% elif param.shape_len == 2 %}
    cast_2d<{{ param.shape[0] }}, {{ param.shape[1] }}, float, W_TYPE>({{ param.name }}_in, {{ param.name }}_fixed_in);
    {% elif param.shape_len == 3 %}
    cast_3d<{{ param.shape[0] }}, {{ param.shape[1] }}, {{ param.shape[2] }}, float, W_TYPE>({{ param.name }}_in, {{ param.name }}_fixed_in);
    {% endif %}
    {% endfor %}

    {# // print all the arrays
    {% for param in model_parameters %}
    printf("{{ param.name }}:\n");
    {% if param.shape_len == 1 %}
    print_1d<{{ param.shape[0] }}>({{ param.name }}_fixed_in);
    {% elif param.shape_len == 2 %}
    print_2d<{{ param.shape[0] }}, {{ param.shape[1] }}>({{ param.name }}_fixed_in);
    {% elif param.shape_len == 3 %}
    print_3d<{{ param.shape[0] }}, {{ param.shape[1] }}, {{ param.shape[2] }}>({{ param.name }}_fixed_in);
    {% endif %}
    printf("\n");
    {% endfor %} #}

}

void print_graph(int graph_idx,
                 int num_nodes,
                 int num_edges,
                 int edge_list[{{max_edges}}][2],
                 float node_feature_table[{{max_nodes}}][{{ input_node_features_dim }}],
                 float model_output_golden_float[{{ output_features_dim }}],
                 float task_golden_output[{{ output_features_dim }}]){
    printf("=== graph %d ===\n", graph_idx);
    printf("num_nodes: %d\n", num_nodes);
    printf("num_edges: %d\n", num_edges);
    printf("edge_list:\n");
    for(int i = 0; i < num_edges; i++){
        printf("%d %d\n", edge_list[i][0], edge_list[i][1]);
    }
    printf("node_feature_table:\n");
    for(int i = 0; i < num_nodes; i++){
        for(int j = 0; j < {{ input_node_features_dim }}; j++){
            printf("%f ", node_feature_table[i][j]);
        }
        printf("\n");
    }
    printf("model_output_golden_float:\n");
    for(int i = 0; i < {{ output_features_dim }}; i++){
        printf("%f ", model_output_golden_float[i]);
    }
    printf("\n");
    printf("task_golden_output:\n");
    for(int i = 0; i < {{ output_features_dim }}; i++){
        printf("%f ", task_golden_output[i]);
    }
    printf("\n");
}

void load_graph(int idx){
    int graph_info[2];
    // int num_nodes;
    // int num_edges;

    // files:
    // ./tb_data/graphs/graph_<idx>_info.bin
    // ./tb_data/graphs/graph_<idx>_coo.bin
    // ./tb_data/graphs/graph_<idx>_node_features.bin
    // ./tb_data/graphs/graph_<idx>_model_golden_output.bin
    // ./tb_data/graphs/graph_<idx>_task_golden_output.bin

    std::string fp_string;

    fp_string = "./tb_data/graphs/graph_" + std::to_string(idx) + "_info.bin";  
    load_data_var_1d<2, int>(fp_string.c_str(), graph_info, 2);
    num_nodes_in = graph_info[0];
    num_edges_in = graph_info[1];
    
    fp_string = "./tb_data/graphs/graph_" + std::to_string(idx) + "_coo.bin";
    load_data_var_2d<{{ max_edges }}, 2, int>(fp_string.c_str(), edge_list_in, num_edges_in, 2);

    fp_string = "./tb_data/graphs/graph_" + std::to_string(idx) + "_node_features.bin";
    load_data_var_2d<{{ max_nodes }}, {{ input_node_features_dim }}, float>(fp_string.c_str(), node_feature_table_in, num_nodes_in, {{ input_node_features_dim }});
    cast_2d<{{ max_nodes }}, {{ input_node_features_dim }}, float, W_TYPE>(node_feature_table_in, node_feature_table_fixed_in);

    fp_string = "./tb_data/graphs/graph_" + std::to_string(idx) + "_model_golden_output.bin";
    load_data_var_1d<{{ output_features_dim }}, float>(fp_string.c_str(), model_output_golden_float, {{ output_features_dim }});

    fp_string = "./tb_data/graphs/graph_" + std::to_string(idx) + "_task_golden_output.bin";
    load_data_var_1d<{{ output_features_dim }}, float>(fp_string.c_str(), task_golden_output, {{ output_features_dim }});
}

int read_total_num_of_graphs(){
    int total_num_of_graphs;
    FILE *fp = fopen("./tb_data/dataset_info.txt", "r");
    fscanf(fp, "num_graphs %d", &total_num_of_graphs);
    fclose(fp);
    return total_num_of_graphs;

}

void call_kernel(int copy_parameters_flag){
    {{model_top_name}}_top(
            node_feature_table_fixed_in,
            edge_list_in,
            model_output_kernel_fixed,
            num_nodes_in,
            num_edges_in,
            copy_parameters_flag,
{% for param in model_parameters %}
            {{ param.name }}_fixed_in{{ "," if not loop.last }}
{% endfor %}
        );
}


int main() {
    // printf("########################\n");
    // printf("# GNNBuilder Testbench #\n");
    // printf("########################\n");
    // printf("Loading model parameters...\n");
    std::cout << "########################" << std::endl;
    std::cout << "# GNNBuilder Testbench #" << std::endl;
    std::cout << "########################" << std::endl;

    std::cout << "Loading model parameters..." << std::endl;
    load_tb_parameters();

    std::cout << "Loading weights to the kernel..." << std::endl;
    int copy_parameters_flag_in = 1;
    call_kernel(copy_parameters_flag_in);
    copy_parameters_flag_in = 0;
    
    std::cout << "Evaluating graphs in the dataset..." << std::endl;
    int total_number_of_graphs = read_total_num_of_graphs();

    std::cout << "total_number_of_graphs: " << total_number_of_graphs << std::endl;
    
    // loop over all graphs
    float model_output_mae_sum = 0.0;
    int model_output_mae_count = 0;

    float model_runtime_sum = 0.0;
    int model_runtime_count = 0;

    // make a text file to log the results
    std::ofstream run_log_file ("./tb_data/run_log.txt");

    for(int idx = 0; idx < total_number_of_graphs; idx++){
        std::cout << "graph_idx: " << idx << std::endl;
        std::cout << "loading graph..." << std::endl;
        
        run_log_file << "graph_idx: " << idx << std::endl;
        run_log_file << "loading graph..." << std::endl;


        load_graph(idx);
        // print_graph(idx, num_nodes_in, num_edges_in, edge_list_in, node_feature_table_in, model_output_golden_float, task_golden_output);
        
        auto start = std::chrono::steady_clock::now();
        call_kernel(copy_parameters_flag_in);
        auto end = std::chrono::steady_clock::now();
        auto elapsed_nanoseconds = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start);
        float runtime = (float)elapsed_nanoseconds.count() / (float)1e9;

        cast_1d<{{ output_features_dim }}, W_TYPE, float>(model_output_kernel_fixed, model_output_kernel_float);
        
        // print the golden output and the kenrnel output
        std::cout << "model_output_golden_float:" << std::endl;
        run_log_file << "model_output_golden_float:" << std::endl;

        for(int i = 0; i < {{ output_features_dim }}; i++){
            std::cout << model_output_golden_float[i] << " ";
            run_log_file << model_output_golden_float[i] << " ";
        }
        std::cout << std::endl;
        run_log_file << std::endl;

        std::cout << "model_output_kernel_float:" << std::endl;
        run_log_file << "model_output_kernel_float:" << std::endl;
        for(int i = 0; i < {{ output_features_dim }}; i++){

            std::cout << model_output_kernel_float[i] << " ";
            run_log_file << model_output_kernel_float[i] << " ";
        }
        std::cout << std::endl;
        run_log_file << std::endl;


        std::cout << "task_golden_output:" << std::endl;
        run_log_file << "task_golden_output:" << std::endl;
        for(int i = 0; i < {{ output_features_dim }}; i++){
            std::cout << task_golden_output[i] << " ";
            run_log_file << task_golden_output[i] << " ";
        }
        std::cout << std::endl;
        run_log_file << std::endl;

        std::cout << "--------------" << std::endl;
        run_log_file << "--------------" << std::endl;

        for(int i = 0; i < {{ output_features_dim }}; i++){
            model_output_mae_sum += std::abs(model_output_golden_float[i] - model_output_kernel_float[i]);
            model_output_mae_count += 1;
        }

        model_runtime_sum += runtime;
        model_runtime_count += 1;
    }

    // close log file
    run_log_file.close();

    float model_output_mae = model_output_mae_sum / model_output_mae_count;
    std::cout << "model_output_mae: " << model_output_mae << std::endl;
    std::ofstream mae_file ("./tb_data/model_output_mae.txt");
    mae_file << "model_output_mae " << model_output_mae << std::endl;
    mae_file.close();

    float model_runtime = model_runtime_sum / model_runtime_count;
    std::cout << "model_runtime: " << model_runtime << std::endl;
    std::ofstream runtime_file ("./tb_data/model_runtime.txt");
    runtime_file << "model_runtime " << model_runtime << std::endl;
    runtime_file.close();
}